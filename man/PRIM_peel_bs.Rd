% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PRIM_peel_bs.R
\name{PRIM_peel_bs}
\alias{PRIM_peel_bs}
\title{Multiple Peeling-Function}
\usage{
PRIM_peel_bs(formula, data, peel_alpha = seq(0.01, 0.4, 0.03), B = 0,
  beta_min = 0.01, target = mean, alter_crit = TRUE, use_NAs = TRUE,
  seed, print_position = TRUE)
}
\arguments{
\item{formula}{an object of class "\code{\link{formula}}" with a response but no interaction terms.
It indicates the response over which the target function should be maximized and the covariates that are used for the later box definitions.}

\item{data}{an object of class \code{\link{data.frame}} containing the variables named in the formula.}

\item{peel_alpha}{vector of a sequence of different alpha-fractions used for the peelings.}

\item{B}{number of bootstrap samples on which the peeling is applied to for each alpha. For \code{B = 0} no bootstraps are created.}

\item{beta_min}{minimum support that one Box should have (stop-criterion).}

\item{target}{target-function to be maximized.}

\item{alter_crit}{logical. If \code{TRUE} the alternative criterion is used for peeling.}

\item{use_NAs}{logical. If \code{TRUE} observations with missing values are included in the analysis.}

\item{seed}{seed to be set before the first iteration. Only useful for \code{B > 0}.}

\item{print_position}{logical. If \code{TRUE} the current position of the algorithm is printed out.}
}
\value{
\code{PRIM_peel_bs} returns an object of class "\code{peel}", which is a list containing at least the following components:

\item{f}{vector of the target functions evaluated on the box at each peeling step.}

\item{beta}{vector of the supports beta of the boxes at each peeling step.}

\item{box}{a \code{\link{data.frame}} defining the borders of the boxes. Each row belongs to one peeling step. The columns with "\code{min.}" and "\code{max.}" describe the lower and upper boundaries of the at least ordinal covariates. Therefore the value taken is the last one that is \bold{not} included in the current box.

For the nominal variables there are columns for every category they can take. If the category is removed from the box the value \code{FALSE} is taken. The names of these columns are structured like: \code{<variable name>.<category>}

For each variable with missing values (only if \code{use_NAs = TRUE}) there is also a column taking the value \code{FALSE} if the \code{NA}s of this variable are removed from the current box. The names of these columns are structured like: \code{<variable name>.NA}
}

\item{box_metric, box_nom, box_na}{easier to handle definitions of the boxes for other functions}

\item{subsets}{\code{list} of logical vectors indicating the subsets at each peeling step (i.e. the observations that lie in the box)}

\item{data_orig}{original dataset that is used for the peeling.}
}
\description{
This function is an implementation of the multiple Peeling-Algorithm as suggested by Friedman and Fisher (1999). The singular peeling function \code{\link{PRIM_peel}} is repeated for different alpha's and bootstrap samples out of the original data.
}
\details{
The outcome of the \code{formula} can either be numeric, logical or a survival object (see \code{\link{Surv}}). If it is a survival object the \code{target} is set to the number of events per amount of time.

The output of this function can become very large because all outputs of the singular peel function \code{PRIM_peel} are put together in one output.
Therefore it is usefull to remove all the dominated boxes (see \code{\link{remove_dominated}}).
}
\examples{
# generating random data:
set.seed(123)
n <- 500
x1 <- runif(n = n, min = -1)
x2 <- runif(n = n, min = -1)
x3 <- runif(n = n, min = -1)
cat <- as.factor(sample(c("a","b","c", "d"), size = n, replace = TRUE))
wsk <- (1-sqrt(x1^2+x2^2)/sqrt(2))
y <- as.logical(rbinom(n = n, prob = wsk, size = 1))
dat <- cbind.data.frame(y, x1, x2, x3, cat)
#plot(dat$x1, dat$x2, col=dat$y+1, pch=16)
remove(x1, x2, x3, y, wsk, cat, n)

# apply the PRIM_peel_bs function:
prim <- PRIM_peel_bs(formula=y ~ ., data=dat, beta_min = .01)
plot(prim) # multiple trajectory
head(prim$box) # box definitions

}
\references{
Friedman, J. H. and Fisher, N. I., 'Bump hunting in high-dimensional data', Statistics and Computing \bold{9} (2) (1999), 123-143
}
\seealso{
\code{\link{remove_dominated}}, \code{\link{PRIM_peel}}, \code{\link{PRIM_paste}}, \code{\link{PRIM}}
}

