% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PRIM.R
\name{PRIM}
\alias{PRIM}
\title{Combined Function for the Patient Rule Induction Method (PRIM)}
\usage{
PRIM(formula, data, f_min, beta_min = 0.2, max_boxes = Inf,
  peel_alpha = seq(0.01, 0.4, 0.03), B = 0, target = mean,
  alter_crit = TRUE, use_NAs = TRUE, seed, print_position = TRUE,
  paste_alpha = 0.01, max_steps = 50, stop_by_dec = TRUE)
}
\arguments{
\item{formula}{an object of class "\code{\link{formula}}" with a response but no interaction terms.
It indicates the response over which the target function should be maximized and the covariates that are used for the later box definitions.}

\item{data}{an object of class \code{\link{data.frame}} containing the variables named in the formula.}

\item{f_min}{minimum target the final box must have. From all boxes, that fulfill this criterion, the one with the biggest support is taken after the peeling. If this argument is missing the box with the biggest target having at least a support of \code{beta_min} is taken.}

\item{beta_min}{minimum support that one Box must have.}

\item{max_boxes}{maximum number of boxes to be found.}

\item{peel_alpha}{vector of a sequence of different alpha-fractions used for the peelings.}

\item{B}{number of bootstrap samples on which the peeling is applied to for each alpha. For \code{B = 0} no bootstraps are created.}

\item{target}{target-function to be maximized.}

\item{alter_crit}{logical. If \code{TRUE} the alternative criterion is used for peeling.}

\item{use_NAs}{logical. If \code{TRUE} observations with missing values are included in the analysis.}

\item{seed}{seed to be set before the first iteration. Only useful for \code{B > 0}.}

\item{print_position}{logical. If \code{TRUE} the current position of the algorithm is printed out.}

\item{paste_alpha}{alpha-fraction that is pasted to the box at each pasting step}

\item{max_steps}{maximum number of pasting steps the function should make.}

\item{stop_by_dec}{logical. If \code{TRUE} the pasting stops if the target at one step is lower than the target of the last step.}
}
\value{
\code{PRIM} returns an object of class "\code{prim}", which is a list containing at least the following components:
\item{f}{vector of the target functions evaluated on each box. The last element is the target of all observations not lying in a box.}
\item{beta}{vector of the supports of each box. The last element is the fraction of observations not lying in a box.}
\item{box}{a \code{\link{data.frame}} defining the borders of the boxes. Each row belongs to one box. The columns with "\code{min.}" and "\code{max.}" describe the lower and upper boundaries of the at least ordinal covariates. Therefore the value taken is the last one that is \bold{not} included in the current box.

For the nominal variables there are columns for every category they can take. If the category is removed from the box the value \code{FALSE} is taken. The names of these columns are structured like: \code{<variable name>.<category>}

For each variable with missing values (only if \code{use_NAs = TRUE}) there is also a column taking the value \code{FALSE} if the \code{NA}s of this variable are removed from the current box. The names of these columns are structured like: \code{<variable name>.NA}
}
\item{box_metric, box_nom, box_na}{easier to handle definitions of the boxes for other functions}
\item{subsets}{\code{list} of logical vectors indicating the subsets (i.e. the observations that lie in each box)}
\item{fixboxes}{\code{list} of all \code{fixbox}'es defining the final boxes.}
\item{data_orig}{original dataset that is used.}
}
\description{
This function is a automated implementation of PRIM as suggested by Friedman and Fisher (1999).
It includes multiple peeling (\code{\link{PRIM_peel_bs}}), pasting (\code{\link{PRIM_paste}}) and the covering stretegy to find more than one box.
}
\details{
This function repeats the peeling and pasting algorithm for the same settings of the metaparameters until a stop ctiterion is reached.
After each iteration the observations already included in a box are removed from the data, on which the next box is built. This strategy is called covering.
This iteration stops if either \code{max_boxes} is reached or if the target function of the "best" box is lower than the overall target.

In each iteration step this function does a multiple peeling characterized by the sequenz \code{alpha_peel} and \code{B}.
From the peeling output the box defined by \code{beta_min} and \code{f_min} is chosen.
After that the pasting function seeks for boxes with bigger supports and bigger targets and takes the one with the highest target function within the box.
}
\examples{
# generating random data:
set.seed(123)
n <- 500
x1 <- runif(n = n, min = -1)
x2 <- runif(n = n, min = -1)
x3 <- runif(n = n, min = -1)
cat <- as.factor(sample(c("a","b","c", "d"), size = n, replace = TRUE))
wsk <- (1-sqrt(x1^2+x2^2)/sqrt(2))
y <- as.logical(rbinom(n = n, prob = wsk, size = 1))
dat <- cbind.data.frame(y, x1, x2, x3, cat)
plot(dat$x1, dat$x2, col=dat$y+1, pch=16)
remove(x1, x2, x3, y, wsk, cat, n)

# apply the PRIM function to find the best boxes with a support of at least 0.1:
p <- PRIM(y~., data=dat, beta_min = 0.1, max_boxes = 3)
p



}
\references{
Friedman, J. H. and Fisher, N. I., 'Bump hunting in high-dimensional data', Statistics and Computing \bold{9}, 123-143
}
\seealso{
\code{\link{PRIM_peel_bs}}, \code{\link{PRIM_paste}}, \code{\link{define_fixbox}}
}

